{"id":"node_modules/node-vibrant/lib/quantizer/mmcq.js","dependencies":[{"name":"/Users/christianreindl/Code/fenwick-ui/node_modules/node-vibrant/lib/quantizer/mmcq.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/christianreindl/Code/fenwick-ui/node_modules/node-vibrant/src/quantizer/mmcq.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/christianreindl/Code/fenwick-ui/package.json","includedInParent":true,"mtime":1629912362644},{"name":"/Users/christianreindl/Code/fenwick-ui/node_modules/node-vibrant/package.json","includedInParent":true,"mtime":499162500000},{"name":"../color","loc":{"line":6,"column":22},"parent":"/Users/christianreindl/Code/fenwick-ui/node_modules/node-vibrant/lib/quantizer/mmcq.js","resolved":"/Users/christianreindl/Code/fenwick-ui/node_modules/node-vibrant/lib/color.js"},{"name":"./vbox","loc":{"line":7,"column":37},"parent":"/Users/christianreindl/Code/fenwick-ui/node_modules/node-vibrant/lib/quantizer/mmcq.js","resolved":"/Users/christianreindl/Code/fenwick-ui/node_modules/node-vibrant/lib/quantizer/vbox.js"},{"name":"./pqueue","loc":{"line":8,"column":39},"parent":"/Users/christianreindl/Code/fenwick-ui/node_modules/node-vibrant/lib/quantizer/mmcq.js","resolved":"/Users/christianreindl/Code/fenwick-ui/node_modules/node-vibrant/lib/quantizer/pqueue.js"}],"generated":{"js":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar color_1 = require(\"../color\");\nvar vbox_1 = __importDefault(require(\"./vbox\"));\nvar pqueue_1 = __importDefault(require(\"./pqueue\"));\nvar fractByPopulations = 0.75;\nfunction _splitBoxes(pq, target) {\n    var lastSize = pq.size();\n    while (pq.size() < target) {\n        var vbox = pq.pop();\n        if (vbox && vbox.count() > 0) {\n            var _a = vbox.split(), vbox1 = _a[0], vbox2 = _a[1];\n            pq.push(vbox1);\n            if (vbox2 && vbox2.count() > 0)\n                pq.push(vbox2);\n            // No more new boxes, converged\n            if (pq.size() === lastSize) {\n                break;\n            }\n            else {\n                lastSize = pq.size();\n            }\n        }\n        else {\n            break;\n        }\n    }\n}\nvar MMCQ = function (pixels, opts) {\n    if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n        throw new Error('Wrong MMCQ parameters');\n    }\n    var vbox = vbox_1.default.build(pixels);\n    var hist = vbox.hist;\n    var colorCount = Object.keys(hist).length;\n    var pq = new pqueue_1.default(function (a, b) { return a.count() - b.count(); });\n    pq.push(vbox);\n    // first set of colors, sorted by population\n    _splitBoxes(pq, fractByPopulations * opts.colorCount);\n    // Re-order\n    var pq2 = new pqueue_1.default(function (a, b) { return a.count() * a.volume() - b.count() * b.volume(); });\n    pq2.contents = pq.contents;\n    // next set - generate the median cuts using the (npix * vol) sorting.\n    _splitBoxes(pq2, opts.colorCount - pq2.size());\n    // calculate the actual colors\n    return generateSwatches(pq2);\n};\nfunction generateSwatches(pq) {\n    var swatches = [];\n    while (pq.size()) {\n        var v = pq.pop();\n        var color = v.avg();\n        var r = color[0], g = color[1], b = color[2];\n        swatches.push(new color_1.Swatch(color, v.count()));\n    }\n    return swatches;\n}\nexports.default = MMCQ;\n"},"sourceMaps":{"js":{"version":3,"file":"mmcq.js","sourceRoot":"","sources":["../../src/quantizer/mmcq.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Quantizer,\n  Filter,\n  Pixels,\n  ComputedOptions\n} from '../typing'\nimport { Swatch } from '../color'\nimport VBox from './vbox'\nimport PQueue from './pqueue'\n\nconst fractByPopulations = 0.75\n\nfunction _splitBoxes (pq: PQueue<VBox>, target: number): void {\n  let lastSize = pq.size()\n  while (pq.size() < target) {\n    let vbox = pq.pop()\n\n    if (vbox && vbox.count() > 0) {\n      let [vbox1, vbox2] = vbox.split()\n\n      pq.push(vbox1)\n      if (vbox2 && vbox2.count() > 0) pq.push(vbox2)\n\n      // No more new boxes, converged\n      if (pq.size() === lastSize) {\n        break\n      } else {\n        lastSize = pq.size()\n      }\n    } else {\n      break\n    }\n  }\n}\n\nconst MMCQ = (pixels: Pixels, opts: ComputedOptions): Array<Swatch> => {\n  if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n    throw new Error('Wrong MMCQ parameters')\n  }\n\n  let vbox = VBox.build(pixels)\n  let hist = vbox.hist\n  let colorCount = Object.keys(hist).length\n  let pq = new PQueue<VBox>((a, b) => a.count() - b.count())\n\n  pq.push(vbox)\n\n  // first set of colors, sorted by population\n  _splitBoxes(pq, fractByPopulations * opts.colorCount)\n\n  // Re-order\n  let pq2 = new PQueue<VBox>((a, b) => a.count() * a.volume() - b.count() * b.volume())\n  pq2.contents = pq.contents\n\n  // next set - generate the median cuts using the (npix * vol) sorting.\n  _splitBoxes(pq2, opts.colorCount - pq2.size())\n\n  // calculate the actual colors\n  return generateSwatches(pq2)\n}\n\nfunction generateSwatches (pq: PQueue<VBox>) {\n  let swatches: Swatch[] = []\n  while (pq.size()) {\n    let v = pq.pop()\n    let color = v.avg()\n    let [r, g, b] = color\n    swatches.push(new Swatch(color, v.count()))\n  }\n  return swatches\n}\n\nexport default MMCQ\n"]}},"error":null,"hash":"3958ab27a3dd18baf79782e3909d9d5c","cacheData":{"env":{}}}